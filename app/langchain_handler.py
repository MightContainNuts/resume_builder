
from langchain_openai import ChatOpenAI
from dotenv import load_dotenv
import json
from pydantic import BaseModel, Field

from langchain_core.messages import (
    SystemMessage,
)
from pathlib import Path
from app.db_handler import DBHandler



class AIResponse(BaseModel):
    """Response model for the LangChainHandler."""
    cover_letter: str = Field(description="The cover letter generated by the LLM.")
    improvements: str = Field(description="Recommendations to improve their chances of getting the job.")
    time_taken: str = Field(description="Time taken to generate the response.")
    token_count: int = Field(description="Number of tokens used in the response.")

class EvaluateChances(BaseModel):
    """Response model for the LangChainHandler."""
    chances: int = Field(description="Evaluation of the chances of getting the job, based on cover letter and job description.")
    reasoning: str = Field(description="Why the chances are what they are.")

class LangChainHandler:

    def __init__(self):

        load_dotenv()
        self.llm = ChatOpenAI(
            model="gpt-4o-mini",
            temperature=0.7,
            max_retries = 3,
        )

        self.documents = self._load_documents()
        self.job_description = self._load_job_description()


    def create_cover_letter(self) -> AIResponse:
        """Generate a response using the validated query and supplementary documents."""
        print("Creating draft cover letter")

        # Extract user query and documents

        prompt_with_docs = f"""
        Job Description: {self.job_description} Using the documents provided, which are: {self.documents}.
        Match skills from the document and job description and emphasise these in the cover letter
        The cover letter should be no longer than one page and should be in a professional format.
        Add recommendations for the candidate to improve their chances of getting the job.
        """

        # Generate response from LLM
        structured_llm = self.llm.with_structured_output(AIResponse)
        response = structured_llm.invoke([SystemMessage(content=prompt_with_docs)])
        assert isinstance(response, AIResponse), "Response is not of type AIResponse on Generation"
        print(f"Response time = {response.time_taken}, tokens: {response.token_count}")
        return response

    def improve_cover_letter(self, cover_letter_draft) -> AIResponse:
        "create an improved cover letter based on results from the first draft"
        print("Improving cover letter")

        prompt_with_info = f"""
        Cehck the draft cover letter {cover_letter_draft} provided and improve it.
        Look for missed skills that are available in {self.documents} that compliment the skills required or that you
        feel are noteworthy.
        The cover letter should be no longer than one page and should be in a professional format."""

        # Generate response from LLM
        structured_llm = self.llm.with_structured_output(AIResponse)
        final_cover_letter = structured_llm.invoke([SystemMessage(content=prompt_with_info)])
        assert isinstance(final_cover_letter, AIResponse), "Response is not of type AIResponse on Generation"
        print(f"Response time = {final_cover_letter.time_taken}, tokens: {final_cover_letter.token_count}")
        return final_cover_letter

    def analyse_chances(self, final_cover_letter) -> EvaluateChances:
        "Evaluate the chances of getting the job based on the cover letter draft"
        print("Evaluating chances")
        prompt_with_info = f"""
        Evaluate the enhanced cover letter {final_cover_letter} and evaluate against the job description in percentage.
        Summarise your reasoning"""

        # Generate response from LLM
        structured_llm = self.llm.with_structured_output(EvaluateChances)
        response = structured_llm.invoke([SystemMessage(content=prompt_with_info)])
        print(f"Response generated: Chances of getting the job: {response.chances} %")
        print(response.reasoning)
        return response


    @staticmethod
    def _load_documents()->dict|None:
        print("Loading documents")
        """Load assistant guidelines from file."""
        doc_path = Path() / "files" / "documents.json"
        try:
            with open(doc_path, "r") as file:
                return json.load(file)

        except Exception as e:
            print(f"Error loading documents: {e}")


    @staticmethod
    def _load_job_description()->str|None:
        """Load assistant guidelines from file."""
        print("Loading job description")
        doc_path = Path() / "files" / "job_description.txt"
        try:
            with open(doc_path, "r") as file:
                return file.read()

        except Exception as e:
            print(f"Error loading documents: {e}")


    def main(self):
        """one function to rule them all"""
        first_draft = self.create_cover_letter()
        final_cover_letter =self.improve_cover_letter(first_draft.cover_letter)
        self.analyse_chances(final_cover_letter.cover_letter)
        with DBHandler() as db:
            db.store_resume_to_file(final_cover_letter.cover_letter)
